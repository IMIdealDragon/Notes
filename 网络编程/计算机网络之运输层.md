# 运输层协议——TCP UDP

带着问题学习：

1. **两个实体间的通信如何保证可靠性**
2. **实体间出现网络拥塞，如何避免，如何恢复**

首先，传输层协议，是在**端系统**实现的，并且是在**操作系统**层面实现的。操作系统从应用程序获取数据，包装成运输层分组，叫做**报文段**。然后返回给网络层，网络层将其封装成网络层分组，叫做**数据报**。



## UDP工作原理与过程

UDP仅仅是将IP数据报加上目的和源端口号，然后直接发送出去，并没有进行传输层实体间的握手。

> DNS是使用UDP的例子。

适合UDP的例子：

* 一些**实时应用**。真正的数据发送时机，应该由应用层把握，UDP从应用层获取数据，加上端口号，就发送出去了。但是TCP可能有一些复杂的通信机制，会延迟这个交付时间。

* 无需建立连接，可以减小时延。

* 无连接状态，因此不需要维护各种状态，这样可以支持更多的活跃客户。

* 分组首部开销小。每个TCP报文段有20字节，而UDP只有8字节。

  

![1568775872455](D:\A_目标！！！\笔记\网络编程\pic\1568775872455.png)

UDP会提供差错检测（计算校验和），这样使得UDP可以运行在任何底层协议上， 无论是否有差错检测。但是UDP没有错误恢复能力，只能给出警告。

## 面向连接的TCP协议

TCP说的面向连接指的是，两个端系统在进行数据交换前，需要先进行握手互相确认，这种连接不是像电路一样，有连接线，这种连接时存在两个端系统中的状态记录。

> MSS(最大报文段长度)指的是TCP报文段中应用层数据的最大长度。该值由MTU（最大传输单元）来设置。

TCP为用户数据封装上TCP首部，从而形成多个TCP报文段，这些报文段被下传到网络层，网络层将其分别封装上IP首部，然后将这些数据报发送到网络中。当TCP另一端收到一个报文段后，该报文段的数据就被放入该TCP连接的**接收缓冲区**。应用程序从此缓存中读取数据流。

![1568789066581](D:\A_目标！！！\笔记\网络编程\pic\1568789066581.png)

因此，每个TCP连接的组成包括：**一台主机上的缓存   变量   套接字   另一台主机上的缓存 变量  套接字**

#### 下面讨论TCP报文段结构，各个字段的意义及作用：

![1568791179586](D:\A_目标！！！\笔记\网络编程\pic\1568791179586.png)

#### 1.序列号和确认号

序号是建立在字节流上的。

> 举例： A向B发送一个数据流。假设数据流由一个500000字节的数据组成，MSS为1000字节，那么第一个报文段的序号是0，第二个报文段的序号是1000。

主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号

#### 2. 往返时间估计和超时重传

使用超时/重传机制来应对TCP报文段的丢失问题（比如接收方收到了数据，发送ACK丢失，则发送方将一直无法获得确认）。超时时间间隔必须大于往返时间RTT。

**TCP如何估计发送方和接收方的往返时间：**

在某个时刻，做一次SampleRTT测量。在任意时刻，仅为一个已发送但目前尚未被确认的报文段估计一个SampleRTT作为新的SampleRTT值。

更新SampleRTT的方法：

![1568792451208](D:\A_目标！！！\笔记\网络编程\pic\1568792451208.png)

α的参考值是0.125.

**设置和管理重传时间间隔**

![1568792558830](D:\A_目标！！！\笔记\网络编程\pic\1568792558830.png)

初始值建议为1秒

**TCP发送方**的事件：**从应用层接收数据、定时器超时、收到ACK回应**

1. 当从应用层接收到数据时，就把这个应用数据封装到了报文段中，并传给IP，传给IP的同时，TCP启动定时器。
2. 当定时器超时，TCP重传报文段，然后重启定时器。
3. 当收到ACK确认报文段时，更新当前已经确认的字节编号。TCP采用的是**累积确认**（就是确认收到是n序号以及n序号之前的字节，中间有断了，后面就先不确认），sendbase是最早的未被确认的字节，y是ACK的值，如果y > sendbase,则更新sendbase，否则TCP重启定时器。

**冗余ACK**：假如现在收到的完整的字节是0~275，那么这时先发送一个ACK275，然后现在收到数据包是290~310，那我现在中间缺了一部分，这样我就不会确认ACK290，而是继续发送ACK275，所以发了两次ACK275，也就是冗余ACK。

**快速重传**：如果发送方接收到3个冗余ACK，则说明该报文段已经丢失，所以会进行快速重传。

### 流量控制

> 目的：当接收方没有来得及去取接收缓存中的数据，此时通知发送方暂缓发送，防止接收缓存区溢出。

TCP通过让发送方维护一个称为**接收窗口**的变量，来告诉发送方，接收方还有多少可用的缓存空间。

**接收窗口rwnd的计算**：

![1568862393942](D:\A_目标！！！\笔记\网络编程\pic\1568862393942.png)

为了防止当接收窗口从0变为非0，可接收数据时，发送方不能及时知道，TCP规定，当接收窗口为0时，发送方继续发送1个字节的数据，当接收方空出缓存区，接收方将确认回复一个非0的接收窗口值。

UDP不提供流量控制，如果溢出将丢失。

### TCP连接管理

**TIME_WAIT状态的作用**：

主动关闭的socket端会进入TIME_WAIT状态，并且大概持续1-4分钟。

**存在的理由**：

1. 可靠的实现TCP全双工连接的终止。

   若A端主动关闭，则A会发送最后一个FIN的响应ACK。但是这个ACK存在丢失的情况，如果ACK丢失，TIME_WAIT可以重发ACK。否则B端将响应RST分节，在A端将解释为异常出错。

2. 允许老的重复分节在网络中消逝

   可能网络中还有一些重复发送的老的分节尚未到达，那么TIME_WAIT就是等待这些分节到达，免得被下一个建立的新连接接收。

**大量TIME_WAIT造成的影响**：

在**高并发短连接**的TCP服务器上，会出现大量的TIME_WAIT状态。会占用大量的内存。

解决办法：开启TIME_WAIT重用和快速回收。

### 拥塞控制原理

> 网络拥塞：网络中的分组丢包多是因为网络变得拥塞时，由于路由器缓存溢出引起的。因此分组重传将作为网络拥塞的征兆。

TCP采用的拥塞控制的方式是：让每个发送方，根据自己得到的网络的拥塞程度，去限制自己向TCP连接发送数据的速率。

针对上面这种方法，有三个问题需要解决：

1. 一个TCP发送方如何限制流量的发送速率？
2. 一个TCP发送方如何得到网络的拥塞程度
3. 采用何种算法来改变其发送速率？

TCP连接是由发送缓存区，接收缓存区和一些变量组成的，我们这里给TCP增加一个拥塞相关的变量叫**拥塞窗口**。发送方中未被确认的数据量应该小于这个拥塞窗口。这样就限制了发送速率。

定义**丢包事件**：超时或者收到3个冗余的ACK.  如果丢包事件发生了，我们就认为是产生了网络拥塞。

如果丢包事件增加，则减小拥塞窗口，如果丢包确认返回，则增大拥塞窗口。

上面简要的描述了之前提出的三个问题，接下去再具体的讲述TCP的拥塞控制算法。

#### 拥塞控制算法

> 拥塞控制算法主要分为3个部分，1. 慢启动  2. 拥塞避免  3. 快速恢复

**1. 慢启动**

cwnd（拥塞窗口）开始时设置为一个MSS，然后每当收到一个确认报文段就翻倍，形成指数增长。肯定需要结束这种指数增长，因此设置了一个阈值，ssthread。这个阈值的使用方法有几种，一种是，在检测到拥塞时，将阈值减小为cwnd的一半，还有一种是，直接就是和cwnd相关联。这样，一旦cwnd等于阈值的时候，就结束慢启动，进入拥塞避免模式。

还有一种慢启动方式是，如果收到三个冗余ACK，就执行一次快速重传，进入快速恢复模式。

**2. 拥塞避免**

此时的cwnd的值大约为上一次遇到拥塞时的值的一半，即距离拥塞并不遥远。每个RTT时间内，增加一个MSS。结束的方式和慢启动过程一样。

**3. 快速恢复**

在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值增加一个MSS,最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。