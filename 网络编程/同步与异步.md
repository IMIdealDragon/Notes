# 网络编程中的同步与异步

网络编程中涉及到同步与异步，这里做一个概念上的区分。

首先，同步与异步分为IO的同步与异步，事件的同步与异步。

IO的同步与异步往往是与内核有关系，看你是不是需要内核通过信号等机制去告诉你当前的IO 操作完成。

事件的同步异步由应用程序来设计，判断的标准就是**监听的线程是否负责读数据**。

在muduo网络库中，一个线程负责监听，其他线程负责读取数据，这种模式下，事件是异步的，监听的线程可以不被读数据所耽误。



**单线程同步muduo方案5：NTP**

同一个线程里面epoll_wait，再读写数据。

> 适合IO密集型，不适合CPU密集型，无法发挥多核的威力

**多线程同步（Reactor）：Netty**

多线程共用一个epoll_fd，每个线程都epoll_wait和读写数据。

**多线程异步（）**

这个的话，就是多线程+异步处理，根据不同的异步处理方式，可以分成不同的模型

比如：一个线程监听连接，在其他线程中read或者recv以及处理计算   muduo方案8

> 相比较半同步半异步来说，其计算效率可以更高，工作线程都在处理，没有epoll_wait的时候，但是
>
> 缺点是，多个线程需要维护一个全局的epollfd和fd集合，fd存在线程安全问题。

还有**领导者/跟随者模型**：轮流epoll_wait，这个也是一个全局的epollfd

1. 有若干个线程(一般组成线程池)用来处理大量的事件
2. 有一个线程作为领导者，等待事件的发生；其他的线程作为追随者，仅仅是睡眠。
3. 假如有事件需要处理，领导者会从追随者中指定一个新的领导者，自己去处理事件。
4. 唤醒的追随者作为新的领导者等待事件的发生。
5. 处理事件的线程处理完毕以后，就会成为追随者的一员，直到被唤醒成为领导者。
6. 假如需要处理的事件太多，而线程数量不够(能够动态创建线程处理另当别论)，则有的事件可能会得不到处理。

> 优点：避免线程间的竞态，领导者线程自己监听I/O事件并处理客户请求，因而领导者/追随者模式不需要在线程之间传递任额外的数据，也无须像半同步半异步reactor模式那样在线程间同步对请求队列的访问，
>
> 缺点：仅支持一个时间源集合，无法让每个工作线程独立的管理多个客户连接。需要看fd是否被关闭，关闭就要将其从epoll中删除，避免无效的fd

**单线程异步（纯异步，采用异步IO的api）：redis？，HAProxy**

单线程，可怎么异步？

**半同步半异步：Netty，muduo，memcached，libevent**

长连接的TCP请求做异步处理，短连接http和定时器请求等做同步处理

或者呢：

一个线程负责accept连接，把建立的连接放到任务队列，然后工作线程从任务队列中取任务，每个工作线程可以负责多个任务的数据处理，也就是每个线程都有epoll_wait。这里的话主线程是异步，而工作线程是同步的。

**多进程同步：fastcgi**

**多进程异步：nginx**

**每请求每进程（线程）：Apache/CGI**

per进程：并发数要小，且是长连接，计算响应的工作量远大于fork的开销，例如：数据库服务器

per线程：开销比进程小，但是伸缩性受线程数量的影响

**微进程框架：erlang/go/lua**

**协程框架：libco**



## Memcached

 Memcached使用libevent实现事件循环，libevent在Linux环境下默认采用epoll作为IO多路复用方法. 用户线程使用libevent则通常按以下步骤： (1).用户线程通过event_init()函数创建一个event_base对象。event_base对象管理所有注册到自己内部的IO事件。多线程环境下，event_base对象不能被多个线程共享，即一个event_base对象只能对应一个线程。 (2).然后该线程通过event_add函数，将与自己感兴趣的文件描述符相关的IO事件，注册到event_base对象，同时指定事件发生时所要调用的事件处理函数（event handler）。服务器程序通常监听套接字（socket）的可读事件。比如，服务器线程注册套接字sock1的EV_READ事件，并指定event_handler1()为该事件的回调函数。libevent将IO事件封装成struct event类型对象，事件类型用EV_READ/EV_WRITE等常量标志。 (3).注册完事件之后，线程调用event_base_loop进入循环监听（monitor）状态。该循环内部会调用epoll等IO复用函数进入阻塞状态，直到描述符上发生自己感兴趣的事件。此时，线程会调用事先指定的回调函数处理该事件。例如，当套接字sock1发生可读事件，即sock1的内核buff中已有可读数据时，被阻塞的线程立即返回（wake up）并调用event_handler1()函数来处理该次事件。 (4).处理完这次监听获得的事件后，线程再次进入阻塞状态并监听，直到下次事件发生。 





