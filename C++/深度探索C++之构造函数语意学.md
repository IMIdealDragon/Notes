# 构造函数语意学

[TOC]

默认构造函数只在需要的时候被合成，那么什么时候是需要的时候，就是编译器只管他自己，如果编译器用到了，就给你合成。C++标准中给出了四种能合成有用的默认构造函数的情况：

## 1. 含有一个  带有默认构造函数的  类对象成员

```cpp
class MATX
{
public:
	MATX() //默认构造函数
	{
		cout << "goodHAHAHAHA" << endl;
	}
};
class MBTX
{
public:
	int m_i;
	int m_j;
    
	MATX ma; //类类型成员变量
	
	void funct()
	{
		cout << "IAmVeryGood" << endl;
	}
};

```


(1)该类MBTX没有任何构造函数，但包含一个类类型的成员ma,而该对象ma所属于的类MATX 有一个缺省的构造函数。这个时候，编译器就会为该类MBTX生成一个 “合成默认的构造函数”，合成的**目的**是为了调用MATX里的默认构造函数。换句话说：**编译器合成了默认的MBTX构造函数，并且在其中 安插代码，调用MATX的缺省构造函数**；



## 2. 带有 默认构造函数的 基类



(2)父类带缺省构造函数，子类没有任何构造函数，但是因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数。合成的目的是为了调用这个父类的构造函数。换句话说，**编译器合成了默认的构造函数，并在其中安插代码，调用其父类的缺省构造函数。**



## 3. 带有一个Virtual Function  的 Class

 (3)如果一个类含有虚函数，但没有任何构造函数时
因为虚函数的存在，
a) 编译器会给我们生成一个基于该类的虚函数表vftable。
b) 编译给我们合成了一个构造函数，并且在其中安插代码： **把类的虚函数表地址赋给类对象的虚函数表指针 （赋值语句/代码）**;
**我们可以把 虚函数表指针  看成是我们表面上看不见的一个类的成员函数,**

编译器给我们往MBTX缺省构造函数中增加了代码：
（a）**生成了类MBTX的虚函数表**
（b）**调用了父类的构造函数**
当我们有自己的默认构造函数时，编译器会根据需要扩充我们自己写的构造函数代码，比如调用父类构造函数，给对象的虚函数表指针赋值。
编译器干了很多事，没默认构造函数时必要情况下帮助我们合成默认构造函数，如果我们有默认构造函数，编译器会根据需要扩充默认构造函数里边的代码。



## 4. 带有一个 Virtual Base Class 的Class

（4）如果一个类带有虚基类，编译器也会为它合成一个默认构造函数。
**虚基类**：通过两个直接基类继承同一个间接基类。所以一般是三层 ，分别是爷爷Grand，有两个爹A,A2，有孙子C

![1562076881083](D:\A_目标！！！\笔记\C++\pic\1562076881083.png)

```cpp
class Grand //爷爷类
{
public:
};

class A : virtual public Grand  //爸爸类
{
public:
};

class A2 : virtual public Grand  //爸爸类
{
public:
};

class C :public A, public A2 //这里不需要virtual
{
public:
	C()
	{
		int aa;
		aa = 1;
	}
};
```

如果是正常的继承，孙子类中会有两份爷爷类，会造成一些问题，而采用虚基类，在孙子类中，爷爷类只有一份，可以避免冲突。

vbtable虚基类表。    vftalble(虚函数表）；
虚基类结构，编译器为子类和父类都产生了“合成的默认构造函数”





## 总结

有四种情况，会导致“编译器必须为为声明构造函数的类合成一个默认构造函数”。C++标准把那些合成物称为implicit nontrival default constructors(隐含有用默认构造函数)。被合成出来的constructor只能满足**编译器（而非程序）的需要**。它是借着“**调用member object 或 base class的default constructors**”或是**为每一个 object初始化其virtual function机制或者virtual base机制**而完成的。也就是说这些都是因为C++本身机制的需要而才合成的。

对于除了这个四种以外的情况，我们认为它们拥有的是implicit trivial default constructors(隐含的有用的默认构造函数)，**它们实际上不会被合成出来**。



还值得注意的是：在默认构造函数中，只有 base class subobjects 和 member class bojects会被初始化，**所有其它的nonstatic data memeber ，如整数，指针，数组等等都不会被初始化（非静态局部对象不初始化则是地址中之前的残留值）**。这些初始化对于程序来说是至关重要的，但是对于编译器来说并非必要，因此它不会去初始化，应该做这些事情的是**程序员**!!!



>新手误区：
>
>1. 任何class如果没有定义构造函数，都会被合成出来一个 
>2. 编译器合成出来的默认构造函数会明确设定“ class 内 每一个 data member 的默认值 ”

如上述分析，这两个都是严重错误的。