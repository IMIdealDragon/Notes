# 深度探索C++之拷贝构造函数

[TOC]

## 何时调用拷贝构造函数

调用拷贝构造函数一共有三种情况，分别是，同类对象赋值，作为形参传入，作为函数返回值。后两者是比较隐含的，不太显眼。

```cpp
class A {};
A a;
A b = a;//1.同类赋值
void func(A a);//2.作为函数形参
A func(int a); //3.作为函数返回值
```

## 怎么拷贝？——两种拷贝机制

C++编译器有两种拷贝机制：memberwise  和  bitwise。具体来说，就是 逐成员拷贝 和 逐位拷贝 。

其中编译器会默认的按位去拷贝。按位拷贝就是把类里面的内存同样的拷贝一份。这种情况是危险的，因为假如，类中有一个指针成员对象，那么按位拷贝仅仅拷贝了指针变量，却没有拷贝出指针变量所指向的内容，这就造成了两个指针同时指向一个对象，这是危险的。也就是浅拷贝。

所以说，如果编译器为我们合成的拷贝构造函数的是按位拷贝的，那么，我们认为它是trival的，那么编译器何时为我们合成nontrival的拷贝构造函数的呢？

和拷贝构造函数一样， 他有四种情况

## 何时产生nontrival的拷贝构造函数

1. 如果一个类A没有拷贝构造函数，但是类成员变量B。B类含有拷贝构造函数（无论是显示声明还是编译器合成的），那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数。

2. 当类 A 继承自一个基类B   而B存在一个拷贝构造函数时（无论是明确定义的还是合成的）
3. 当类声明了一个或多个虚函数时
4. 当类派生自一个虚基类时。

这四种情况和拷贝构造函数的合成的四种情况是一样的，这两者是一荣俱荣，一损俱损。