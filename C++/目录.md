# C++知识点目录

[TOC]

c++重点关注的语言工具是：1. Rvalue reference（右值引用）;2. function/bind;3. Lambda expression and closure.

## 基础细节问题

###  [const完全解析](const.md)
### [引用和指针的区别](引用和指针的区别.md)
### [指针与数组名的区别](指针与数组名的区别.md)

### [static](static.md)

c++函数栈空间的最大值为1M，可以调整

### 类内定义引用数据成员

 在类中定义引用变量, 必须要在**初始化列表中初始化该成员变量**（**const 类型数据成员也必须在初始化列表中进行初始化**） 

### C++中必须在类初始化列表中初始化的几种情况

 https://blog.csdn.net/YL970302/article/details/89306573 

```markdown
1. const类型的成员变量
2. 引用类型的成员变量
3. 带有引用的类的成员变量
4. 如果类中存在继承关系，派生类必须在初始化列表中调用基类的构造函数
5. 类成员没有默认的构造函数的类类型
```

### new和malloc的区别

 https://blog.csdn.net/linux_ever/article/details/50533149 

## 面向对象的设计

### [三大函数解析](拷贝构造函数.md)

#### 拷贝赋值和拷贝构造能否进行值传递？

> 不能，因为如果形参是值传递，那么在传入参数的时候，就需要先拷贝一份临时对象出来，传入调用的函数，在拷贝临时对象的时候就又会调用拷贝构造函数，就会陷入无限循环。

### [虚函数与多态](虚函数与多态.md)



## 深度探索C++对象模型

### [构造函数语意学](深度探索C++之构造函数语意学.md)



## C++11新特性

#### [c++11新特性](D:\A_目标！！！\笔记\C++\C++11新特性.md)

#### shared_ptr的实现

```markdown
1. 引用计数的管理：可以使用一个指向堆内存的指针，而且需要线程安全的话是要原子的。如果发生一次拷贝构造，引用计数加1，发生一次析构，引用计数减1.拷贝的时候只是浅拷贝，只复制了指针。
2. 拷贝构造函数：if(use) ++ * use
3. 拷贝赋值函数：被赋值对象引用计数+1，本对象引用计数减1，同时判断是否为0，为0则delete
4. 重载运算符：解引用，递增，取成员，加减运算符等。
5. 还需要考虑一些重载
```

 https://blog.csdn.net/qq_41822235/article/details/82934681 

 https://my.oschina.net/costaxu/blog/103119 

 https://cloud.tencent.com/developer/article/1491816 

## [一些个小trick](trick.md)

### ++i 的效率比 i++高

### 在main函数运行之前的代码

#### 1. gcc里面的使用attribute关键字， 声明constructor和destructor函数 

>  __attribute( constructor ) void before_main(){} 

```cpp
#include <stdio.h> 

__attribute__((constructor)) void before_main() { 
   printf("before main\n"); 
} 

__attribute__((destructor)) void after_main() { 
   printf("after main\n"); 
} 
  
int main(int argc, char **argv) { 
   printf("in main\n"); 
   return 0; 
}
```

输出结果为：

> book@virtual:~ $ ./before_main 
> before main
> in main
> after main

#### 2. 全局变量的初始化在main之前，所以可以用全局对象的构造函数

```cpp
#include <iostream>
using namespace std;

int func()
{
	cout<<"func() called before main()"<<endl;
	return 100;
}
class A
{
public:
	A()
	{
		cout<<"A() constructor called"<<endl;
	}
	~A()
	{
		cout<<"~A() destructor called"<<endl;
	}
};

A a;

int g_iValue = func();

int main()
{
	cout<<"main() called"<<endl;
	return 0;
}
```

输出结果为：

> book@virtual:~ $ ./before_main 
> A() constructor called
> func() called before main()
> main() called
> ~A() destructor called

