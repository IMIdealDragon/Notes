# 虚函数与多态

[TOC]

## 类对象的内存模型

1. 空类占据的内存大小是1个字节
2. 成员函数不占据类对象的内存空间，成员函数是跟着类走的，内存中只有一份，不在对象内，对象拥有的是调用权
3. 只要在父类中是虚函数，那么子类不写virtual也是可以的
4. 非静态成员变量占类对象的内存
5. 静态成员变量在类对象内存外部
6. 只要有虚函数，类对象内存会多出4个字节，这4个字节是VPTR，指向虚函数表的指针(windows下是4字节，linux下是8字节)
7. vptr虚函数指针在对象中的位置是在对象的头部（gcc和vs的编译器都是），也许有的编译器会把它放到对象的最底部。（**看看字节对齐**）
## 继承机制

![1561646620515](D:\A_目标！！！\笔记\网络编程\pic\1561646620515.png)

如图所示，继承的时候，从内存角度看，子类会复制，父类的成员变量，而对于成员函数是采用继承其调用权，并没有复制内存。

继承的父类的内存在子类内存的靠前面一部分。

![1561646763323](D:\A_目标！！！\笔记\网络编程\pic\1561646763323.png)

如果有父类中的函数，先定义了，但是不实现，在不同的子类中有着不同的实现，这个时候就用虚函数，虚函数的分为纯虚函数和虚函数。纯虚函数用等于0，表示子类必须有实现，而虚函数是子类可以选择性实现。

### 举例分析

![1561646953547](D:\A_目标！！！\笔记\网络编程\pic\1561646953547.png)

main函数中调用了子类对象myDoc中的OnFileOpen方法，这个方法是在父类中定义的，所以先调用父类中的函数，然后父类中遇到虚函数，会调用子类中实现的函数。这是一个动态绑定的过程。具体的虚函数动态绑定后面解释。

### 静态绑定与动态绑定

讨论静态绑定与动态绑定，首先需要理解的是绑定，何为绑定？函数调用与函数本身的关联，以及成员访问与变量内存地址间的关系，称为绑定。 理解了绑定后再理解静态与动态。

- 静态绑定：指在**程序编译**过程中，把函数调用与响应调用所需的代码结合的过程，称为静态绑定。发生在编译期。
- 动态绑定：指在**执行期间判断所引用对象的实际类型**，根据实际的类型调用其相应的方法。程序运行过程中，把函数调用与响应调用所需的代码相结合的过程称为动态绑定。发生于运行期。

## 虚函数动态绑定

![1561649121831](D:\A_目标！！！\笔记\网络编程\pic\1561649121831.png)

一图以蔽之。

p是父类指针，* (p->vptr)这是通过取虚函数表指针的值，得到虚函数表地址，然后，*(p->vptr)[n]就是取到了虚函数表的第n项，是一个函数指针，然后传入一个p是this指针。

子类中有重写的虚函数，子类中的虚函数表对应的函数会被替换。如果子类中完全没有重写的虚函数，那子类和父类的虚函数表内容是一样的。

子类对象给父类对象赋值问题：

```cpp
Base base = derive;//直接用子类给父类对象值，子类中的属于父类那部分内容会被编译器自动区分（切割出来）
                   //所以Base base = derive:实际干了两件事情：
                       //第一件事情：生成一个base对象
                       //第二件事情：用derive来初始化base对象的值
                       //这里编译器给咱们做了一个选择，显然derive初始化base对象的时候
                      //derive的虚函数指针值并没有覆盖base对象的虚函数表指针值
```

为什么函数调用不产生多态：因为函数调用不在运行时决定，编译时就已经确定了，直接call xxx

## 阿里面试问题：

父类的指针如何访问子类中的数据成员。

1. 虚函数
2.  dynamic_cast
3. 强转 