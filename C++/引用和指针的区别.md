# 指针和引用的区别

## 高级语言层面使用上的区别

```markdown
1. 引用必须被初始化，而指针不用
2. 引用不能为空，而指针可以
3. 引用一旦初始化就不可以改变，而指针可以改变指向
4. sizeof引用得到的是所指向对象的大小，而sizeof指针得到的是指针本身
5. 指针和引用的自增自减运算意义不一样
6. 使用指针必须解引用，而引用不需要
7. **指针和引用都占用内存，很多地方说不占用是不对的**
```

### 代码示例：

>1. 引用必须被初始化，而指针不用
```cpp
    int i = 10;
	int* p ;//正确
	int& r;// error C2530:  “r”: 必须初始化引用
```
>2. 引用不能为空，而指针可以

```cpp
	int i = 10;
	int* p = NULL;//正确
	int& r = NULL;//error C2440:  “初始化”: 无法从“int”转换为“int &”
```

> 3. 引用一旦初始化就不可以改变，而指针可以改变指向

```cpp
	int i = 10;
	int j = 11;
	p = &i;//i = 10, j = 11
	p = &j;//i = 10, j = 11
	int& r = i;
	r = j;//i = 11, j = 11
```

无法让r重新绑定j，而是直接改变了i

>4. sizeof引用得到的是所指向对象的大小，而sizeof指针得到的是指针本身

```cpp
	long long i = 2;
	long long* p = NULL;
	p = &i;
	long long& r = i;
	cout << sizeof p << endl;   //4
	cout << sizeof r << endl;   //8
	cout << sizeof i << endl;   //8
```

>5. 指针和引用的自增自减运算意义不一样

引用自增是对值进行操作的，指针的自增是对地址进行操作的

## 底层机制

> 7. 指针和引用都占用内存

引用被称为变量的别名，它不能脱离被引用对象独立存在，这是在高级语言层面的概念和理解，并未解释引用的实现方式。**常见错误说法是“引用”自身不是一个变量，甚至编译器可以不以引用分配空间**。

实际上，引用本身是一个变量，只不过这个变量的定义和使用与普通变量有显著的不同。为了解引用变量底层实现机制，考查如下代码：

```cpp
int i=5;
int &ri=i;
ri=8;
```

在Visual Studio 2019环境的debug模式调试代码，反汇编查看源码对应的汇编代码的步骤是：调试->窗口->反汇编，即可得到如下原码对应的汇编代码：

```asm
int i=5;
00A013DE  mov        dword ptr [i],5   #将文字常量5送入变量i
int &ri=i;
00A013E5  lea        eax,[i]  	 	   #将变量i的地址送入寄存器eax
00A013E8  mov        dword ptr [ri],eax  #将寄存器的内容（也就是变量i的地址）送入变量ri
ri=8;
00A013EB  mov        eax,dword ptr [ri]  #将变量ri的值送入寄存器eax
00A013EE  mov        dword ptr [eax],8   #将数值8送入以eax的内容为地址的单元中
return 0;
00A013F4  xor        eax,eax
```

考查以上代码，在汇编代码中，ri的数据类型为dword，也就是说，ri要在内存中占据4个字节的位置。所以，ri的确是一个变量，它存放的是被引用对象的地址。由于通常情况下，地址是由指针变量存放的，那么，指针变量和引用变量有什么区别呢？使用指针常量实现上面的代码功能。考查如下代码：

```cpp
int i=5;
int* const pi=&i;
*pi=8;
```

按照相同的方式，在VS2019中得都如下汇编代码：

```assembly
int i=5;
011F13DE  mov         dword ptr [i],5  
int * const pi=&i;
011F13E5  lea         eax,[i]  
011F13E8  mov         dword ptr [pi],eax  
*pi=8;
011F13EB  mov         eax,dword ptr [pi]  
011F13EE  mov         dword ptr [eax],8
```

观察以上代码可以看出：

1. 除了pi与ri变量名不同，所得汇编代码与第一段所对应的汇编代码完全一样。所以，引用变量在功能上等于一个指针常量，即一旦指向某一个单元就不能在指向别处。

2. 在底层，引用变量由指针按照指针常量的方式实现。